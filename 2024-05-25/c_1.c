// 1. 预处理阶段
// 对包含的头文件（#include）和宏定义（#define、#ifdef等）进行处理
// 可以使用 gcc 的选项“-E”进行查看，该选项的作用是让 gcc 在预处理结束后停止编译过程
#include <stdio.h>

int main(int argc, char const *argv[])
{
  printf("Hello, World!\n");
  return 0;
}
// Exec
// gcc -E 2024-05-25/c_1.c -o 2024-05-25/c_1.i 

// 由此可见，gcc 确实进行了预处理，它把“stdio.h”的内容插入 .i 文件中。

// 2. 编译阶段
// 在这个阶段中，gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。
// 可以使用“-S”选项来进行查看，该选项只进行编译而不进行汇编，结果生成汇编代码。

// Exec
// gcc -S 2024-05-25/c_1.c -o 2024-05-25/c_1.s

// 3. 汇编阶段
// 汇编阶段是把编译阶段生成的“.s”文件转成目标文件

// Exec
// gcc -c 2024-05-25/c_1.s -o 2024-05-25/c_1.o

// 4. 链接阶段
// 在成功编译之后，就进入了链接阶段。这里涉及一个重要的概念：函数库。
// 系统把这些函数的实现都放到名为 libc.so.6 的库文件中
// 函数库有静态库和动态库两种。静态库是指编译链接时，将库文件的代码全部加入可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了，其后缀名通常为“.a”。
// 动态库与之相反，在编译链接时并没有将库文件的代码加入可执行文件中，而是在程序执行时加载库，这样可以节省系统的开销。一般动态库的后缀名为“.so”，如前面所述的 libc.so.6 就是动态库。
// gcc 在编译时默认使用动态库。